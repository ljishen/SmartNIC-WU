#!/usr/bin/env bash
#
# This script requires gawk >= 4.0 to support:
#   Arrays of arrays
#
# See "History of gawk Features":
#   https://www.gnu.org/software/gawk/manual/html_node/Feature-History.html

set -euo pipefail

if (( $# != 1 )); then
  cat <<EOF
Usage:    $0 DATAFILE

DATAFILE:
    a datafile summarizes results from all platforms,
    typically ending with '.platforms_summary'.
EOF
  exit
fi

DATAFILE="$1"
if ! [[ -f "$DATAFILE" ]]; then
  echo "[ERROR] DATAFILE does not exist: $DATAFILE" >&2
  exit 1
fi

if [[ "${DATAFILE##*.}" != "platforms_summary" ]]; then
  echo "[ERROR] Unsupport datafile: $DATAFILE" >&2
  exit 1
fi

if ! command -v gawk >/dev/null 2>&1; then
  echo "[ERROR] Please install gawk of version >= 4.0"
  exit 2
fi

vergte() { printf '%s\n%s' "$1" "$2" | sort -rCV; }
if ! vergte "$(gawk 'BEGIN { print PROCINFO["version"] }')" "4.0"; then
  echo "[ERROR] Please update gawk to version >= 4.0"
  exit 2
fi


SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
STRESSOR_CLASSES_FILE="$SCRIPT_DIR"/stressor_classes.txt

STRESSOR_TO_CLASSES_STR="$(gawk '
  BEGIN { stressor_to_classes_str = "" }

  /^[[:alnum:]-]+/ {
    if ($1 == "STRESSOR")
      next

    stressor_name = $1
    $1 = ""
    stressor_classes = $0
    gsub(/[[:blank:]]+/, "", stressor_classes)
    stressor_to_classes_str = stressor_to_classes_str" ["stressor_name"]=\""stressor_classes"\""
  }

  END { print stressor_to_classes_str }
' "$STRESSOR_CLASSES_FILE")"

SUMMARY_FILEPATH="$DATAFILE".per_class
cat <<EOF >"$SUMMARY_FILEPATH"
# This file is generated by script $(basename -- "$0")
# for platform results summarized in file:
# $(basename -- "$DATAFILE")
#
# Each value starting from column 3 is in the form of:
# A/B/C/D/E/F/G/H, where A-D are statistics for the z-scores of str-
# essors and E-H are statistics for the relative performance of str-
# essors to the reference platform.
#
# Specifically, in the first group,  A is the average z-score of all
# stressors in a given stressor class  for a particular platform. B,
# C,  and D are the corresponding sample standard deviation, minimum
# and maximum z-score, respectively.
#
# In the second group, the meaning of the corresponding value is the
# same as that of in the first group, except that each value is cal-
# culated in terms of the relative bogo_ops_ps to the reference pla-
# tform.  For example, E is the average relative  bogo_ops_ps of all
# stressors in a given stressor class for a particular platform.
#
$(grep '^# Reference platform : ' "$DATAFILE")
EOF

IGNORE_STRESSOR_IDXES_STR="$(gawk '
  /^[[:alnum:]_\/-]+\t/ {
    if ($1 == "PLATFORM")
      next

    for (i = 2; i <= NF; i++) {
      if ($i ~ /\ynan$/)
        ignore_stressors[i] = ""
    }
  }

  END {
    for (idx in ignore_stressors)
      ignore_stressor_idxes_str = ignore_stressor_idxes_str" "idx

    print ignore_stressor_idxes_str
  }
' "$DATAFILE")"

gawk \
  -v stressor_to_classes_str="$STRESSOR_TO_CLASSES_STR" \
  -v ignore_stressor_idxes_str="$IGNORE_STRESSOR_IDXES_STR" '
  BEGIN {
    split(stressor_to_classes_str, stressor_to_classes_arr, " ")
    for (i = 1; i <= length(stressor_to_classes_arr); i++) {
      split(stressor_to_classes_arr[i], sc, "=")
      stressor = sc[1]
      gsub(/\[|\]/, "", stressor)
      classes_str = sc[2]
      gsub(/"/, "", classes_str)
      split(classes_str, classes_arr, "|")

      # Map stressor name to stressor classes
      for (j = 1; j <= length(classes_arr); j++) {
        stressor_to_classes[stressor][classes_arr[j]] = ""
      }
    }

    split(ignore_stressor_idxes_str, ignore_stressor_idxes_arr, " ")
    for (i = 1; i < length(stressor_to_classes_arr); i++) {
      ignore_stressor_idxes[ignore_stressor_idxes_arr[i]] = ""
    }
  }

  function update_statistics(platform, class, type, value) {
    platform_to_class_statistics[platform][class][type]["sum"] += value
    platform_to_class_statistics[platform][class][type]["sq_sum"] += value ^ 2

    if ("min" in platform_to_class_statistics[platform][class][type]) {
      if (value < platform_to_class_statistics[platform][class][type]["min"])
        platform_to_class_statistics[platform][class][type]["min"] = value
    } else {
      platform_to_class_statistics[platform][class][type]["min"] = value
    }

    if ("max" in platform_to_class_statistics[platform][class][type]) {
      if (value > platform_to_class_statistics[platform][class][type]["max"])
        platform_to_class_statistics[platform][class][type]["max"] = value
    } else {
      platform_to_class_statistics[platform][class][type]["max"] = value
    }
  }

  /^[[:alnum:]_\/-]+\t/ {
    if ($1 == "PLATFORM") {
      for (i = 2; i <= NF; i++) {
        # Map stressor column idx to stressor name
        stressors[i] = $i

        if (i in ignore_stressor_idxes)
          print "Ignore stressor: "$i > "/dev/stderr"
      }
      next
    } else {
      platform = $1
      platforms[platform] = ""

      for (i = 2; i <= NF; i++) {
        if (i in ignore_stressor_idxes)
          continue

        stressor = stressors[i]

        split($i, tuple, "/")
        zscore = tuple[2]
        relative_value = tuple[3]

        # This is important because it explicitly tells awk that
        # we are using it as a number, and not as a string.
        # Otherwise, the following number comparision operations
        # may work as string comparision.
        zscore *= 1.0
        relative_value *= 1.0

        for (class in stressor_to_classes[stressor]) {
          all_classes[class][stressor] = ""

          update_statistics(platform, class, "zscore", zscore)
          update_statistics(platform, class, "relative_value", relative_value)
        }
      }
    }
  }

  function print_values(platform, class, type) {
    sq_sum = platform_to_class_statistics[platform][class][type]["sq_sum"]
    num_val = length(all_classes[class])
    mean = platform_to_class_statistics[platform][class][type]["sum"] / num_val
    stdev = sqrt((sq_sum - num_val * mean ^ 2) / (num_val - 1))

    printf "%.6f/%.6f/%.6f/%.6f",
      mean,
      stdev,
      platform_to_class_statistics[platform][class][type]["min"],
      platform_to_class_statistics[platform][class][type]["max"]
  }

  END {
    printf "# Number of stressor classes: %d\n", length(all_classes)
    printf "# Number of platforms: %d\n\n\n", length(platforms)

    # Print header
    printf "STRESSOR_CLASS\tNUM_STRESSORS"
    for (platform in platforms) {
      printf "\t%s", platform
    }
    printf "\n\n"

    for (class in all_classes) {
      printf "%s\t%d", class, length(all_classes[class])
      for (platform in platforms) {
        printf "\t"
        print_values(platform, class, "zscore")
        printf "/"
        print_values(platform, class, "relative_value")
      }
      printf "\n"
    }
  }
' "$DATAFILE" >>"$SUMMARY_FILEPATH"

printf '\nWritten summary file to %s\n' "$SUMMARY_FILEPATH"
